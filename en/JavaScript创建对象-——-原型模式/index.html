<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>JavaScript创建对象 —— 原型模式 | zsdfBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象我们叫它原型对象。而这个原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。它所包含的属性和方法可以被所有对象实例共享。所以说，在定义构造函数时，不必在其中定义属性和方法，而是在原型对象中定义。如下：    function Person{ }; Person.prototype.nam">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript创建对象 —— 原型模式">
<meta property="og:url" content="http://yoursite.com/zsdf/en/JavaScript创建对象-——-原型模式/index.html">
<meta property="og:site_name" content="zsdfBlog">
<meta property="og:description" content="我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象我们叫它原型对象。而这个原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。它所包含的属性和方法可以被所有对象实例共享。所以说，在定义构造函数时，不必在其中定义属性和方法，而是在原型对象中定义。如下：    function Person{ }; Person.prototype.nam">
<meta property="og:locale" content="default">
<meta property="og:image" content="https://img-blog.csdn.net/20170409200946587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170409204227944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:image" content="https://img-blog.csdn.net/20170409230739517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
<meta property="og:updated_time" content="2018-08-23T03:36:30.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JavaScript创建对象 —— 原型模式">
<meta name="twitter:description" content="我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象我们叫它原型对象。而这个原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。它所包含的属性和方法可以被所有对象实例共享。所以说，在定义构造函数时，不必在其中定义属性和方法，而是在原型对象中定义。如下：    function Person{ }; Person.prototype.nam">
<meta name="twitter:image" content="https://img-blog.csdn.net/20170409200946587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast">
  
    <link rel="alternate" href="/zsdf/atom.xml" title="zsdfBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/zsdf/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/zsdf/" id="logo">zsdfBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/zsdf/" id="subtitle">zsdf</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/zsdf/">Home</a>
        
          <a class="main-nav-link" href="/zsdf/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/zsdf/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com/zsdf"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-JavaScript创建对象-——-原型模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/JavaScript创建对象-——-原型模式/" class="article-date">
  <time datetime="2017-04-09T13:01:24.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      JavaScript创建对象 —— 原型模式
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象我们叫它原型对象。而这个原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。它所包含的属性和方法可以被所有对象实例共享。所以说，在定义构造函数时，不必在其中定义属性和方法，而是在原型对象中定义。如下：</p>
<pre><code>   function Person{
};
Person.prototype.name = &quot;zhangsan&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Enginner&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var person1 = new Person();
person1.sayName();    //zhangsan

var person2 = new Person();
person2.sayName();    //zhangsan
</code></pre><p>person1和person2访问的是同一组属性和同一个方法。</p>
<p><strong>1. 原型对象</strong><br>再说了这么多，接下来了解一下原型对象到底是什么,看图说话：<br><img src="https://img-blog.csdn.net/20170409200946587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>以上面的例子来说：</p>
<p>创建了Person构造函数。原型对象会默认取得constructor属性。Person.prototype指向Person.prototype.constructor<br>Person.prototype.constructor指向Person</p>
<p>再看看开头的几句话。结合图再熟悉一下。我们在例子中定义的属性和方法都添加到了原型对象中。实例化的对象Person1和Person2都可以访问，哪怕还有一个Person10，都可以。</p>
<p>我们注意到，实例化的两个对象都不含有属性和方法，却可以调用Person1.sayName().这是通过查找对象属性的过程来实现的。</p>
<p>来看看是怎样进行查找的：<br><strong>图中我们发现没有什么可以指向Person中的[[Prototype]],但是有isPrototypeOf()方法来确定对象之间是否存在这种关系：</strong><br>alert(Person.prototype.isPrototypeOf(person1)); //true</p>
<p>所以我们知道实例化的对象内部都有一个指向Person.prototype的指针。</p>
<p>还有一个Object.getPrototypeOf()方法。 [[prototype]]的值</p>
<p>alert(Object.getPrototypeOf(person1) == Person.prototype);</p>
<p>//true</p>
<p>因person1中的[[prototype]]与 Person.prototype指的是同一对象。</p>
<p>那么如果实例对象想定义自己的属性和方法怎么办？会不会担心与原型对象中的命名冲突？</p>
<p>其实在实例中创建与原型对象中相同名字的属性和方法，该属性将会覆盖掉原型对象中的同名属性。</p>
<p>还是刚开始的那段代码，在实例时这样：</p>
<pre><code>var person1 = new Person();
person1.name = &quot;lisi&quot;;
person1.name();    //lisi

var person2 = new Person();
person2.sayName();    //zhangsan
</code></pre><p>在定义了实例对象自己的属性或者方法后，如果不想用了，可以利用delete person1.name删除它。删除之后它和原型对象之间的联系又接上了，相当于什么事都没有发生过。还可以照常访问。</p>
<p>既然现在知道了实例中也可以定义属性和方法，怎样判断属性在实例中还是在原型对象中？hasOwnProperty()方法可以进行判断。</p>
<pre><code>var person1 = new Person();

//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //false

person1.name = &quot;lisi&quot;;       //person1定义一个名为name的属性
//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //true

var person2 = new Person();
alert(person2.hasOwnProperty(&quot;name&quot;));   //false
</code></pre><p>看图说话<br><img src="https://img-blog.csdn.net/20170409204227944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>2. 原型与in操作符</strong></p>
<pre><code>var person1 = new Person();

//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //false
alert(&quot;name&quot; in person1);   //true;

person1.name = &quot;lisi&quot;;       //person1定义一个名为name的属性
//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //true
alert(&quot;name&quot; in person1);   //true;
</code></pre><p>由上可以得出结论，无论属性在实例中还是在原型中，不能用in来进行判断。但是同时使用hasOwnProperty（）和in就可以准确的进行判断。</p>
<p>for-in循环，返回的是所有可通过对象访问的，可枚举的属性。</p>
<p>要取得对象上所有可枚举的属性，使用Object.keys(对象)；</p>
<p>还是以第一个例子为例：</p>
<pre><code>var keys = Object.keys(Person.prototype);
alert(keys)    //name, age, job, sayName

var p = new Person();
p.name = &quot;lisi&quot;;
p.age = 31;
var keys = Object.keys(p);
alert(keys)    //name, age,
</code></pre><p>如果想要得到所有的实例，无论是否可枚举，使用 Object.getOwnPropertyNames()方法</p>
<p>var keys = Object.getOwnPropertyNames(Person.prototype);<br>alert(keys) //constructor, name, age, job, sayName</p>
<p><strong>3. 使用对象字面量来重写原型对象：</strong><br>function Person{<br>};<br>Person.prototype = {<br><strong>constructor:Person,</strong><br>name ： “zhangsan”,<br>age ： 29,<br>job ： “Software Enginner”,<br>sayName ： function(){<br>alert(this.name);<br>}<br>};</p>
<p>注意黑色加粗部分，因为每创建一个函数，就会同时创建它的prototype对象，因此，这个对象也会自动获得constructor属性，而我们在这里使用的语法完全是重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性。</p>
<p>注意以这种方式设置的constructor属性会导致它的[[Enumerable]]特性是可枚举的，但默认情况下，原生的constructor属性不可枚举。所以使用Object.defineProperty()修改默认属性</p>
<p>//重设构造函数，只适用于ECMAScript5兼容的浏览器<br>Object.defineProperty(person.prototype, “constructor”, {<br>enumerable:false;<br>value:Person<br>});</p>
<p><strong>4. 原型的动态性</strong><br>原型的动态性是什么意思。就是你对原型对象所做的修改会立即在实例中反映出来。即使这个对象在修改原型对象属性之前创建。</p>
<pre><code>var person1 = new Person();

Person.prototype.sayHi = function(){
    alert(&apos;Hi&apos;);
}
person1.sayHi();     //Hi 
</code></pre><p>这是因为我们在找sayHi函数时，首先会在实例中寻找，没有的话再向原型对象中寻找。因为原型对象与实例之间的链接只不过是一个指针，在找到之后，会返回最新的sayHi属性，并返回保存在那里的函数。</p>
<p>尽管可以随时为原型添加属性和方法，并且能够立即在对象实例中反映出来，但如果重写整个原型对象，结果就不一样了</p>
<p>function Person{<br>};</p>
<p>var friend = new Person();</p>
<p>Person.prototype = {<br>constructor:Person,<br>name ： “zhangsan”,<br>age ： 29,<br>job ： “Software Enginner”,<br>sayName ： function(){<br>alert(this.name);<br>}<br>};<br>friend.sayName(); //error</p>
<p><img src="https://img-blog.csdn.net/20170409230739517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这是因为，我们知道每创建一个函数，就会自动生成一个原型对象。<br>上面当定义了一个Person构造函数时，其实就已经默认的生成了一个原型对象。只不过没有属性和方法。后来实例了一个对象，此对象指向的是当前没有属性和方法的只有constructor属性的一个原型对象。<br>后来又创建了一个Person的包含属性和方法的原型对象。但是friend却不是指向这个。<br>简言之就是该Person构造函数包含了自身的原型对象和创建的原型对象。</p>
<p><strong>5. 原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型的方面，就连所有原生的引用类型，就是采用这种模式创建的。<br>如Array.sort()可以在Array.prototype.sort()中也可以访问得到。</p>
<p>所以我们还可以为原型对象的属性和方法进行修改。如添加一个自己定义的函数</p>
<pre><code>Array.prototype.aaa = function(){
    alert(&apos;hello world&apos;);
}

var strings = new Array();
strings.aaa();   //hello world
</code></pre><p><strong>6. 原型对象的问题：</strong><br>对于包含引用类型值得属性来说，原型对象的问题比较突出</p>
<pre><code>   function Person{
};


Person.prototype = {
    constructor:Person,
    name ： &quot;zhangsan&quot;,
    age ： 29,
    job ： &quot;Software Enginner&quot;,
    friends:[&quot;aa&quot;, &quot;bb&quot;],
   sayName ： function(){
    alert(this.name);
}
};
var friend1 = new Person();
var friend 2= new Person();

friend1.friends.push(&apos;cc&apos;);
alert(friend1.friends);    //aa, bb, cc
alert(friend2.friends);    //aa, bb, cc
</code></pre><p>因为friends属性存在于Person.prototype而非friend1中，所以修改原型对象中的属性，也会反映在其他实例中。但是实例一般都要有属于自己的属性和方法，<strong>所以说这也是很少单独使用原型模式的原因了</strong>。</p>
<p>所以就会出现<strong>组合使用构造函数模式和原型模式创建JavaScript对象。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/JavaScript创建对象-——-原型模式/" data-id="cjl60q3l5001m75tf20hf8lly" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/zsdf/en/组合使用构造函数模式和原型模式/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          组合使用构造函数模式和原型模式
        
      </div>
    </a>
  
  
    <a href="/zsdf/en/理解立即调用函数-function/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">理解立即调用函数(function(){ ...})();</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/zsdf/tw/Hello-World/">Hello World</a>
          </li>
        
          <li>
            <a href="/zsdf/en/post-Asset-Folder/">post_Asset_Folder</a>
          </li>
        
          <li>
            <a href="/zsdf/en/My-Gallery/">My Gallery</a>
          </li>
        
          <li>
            <a href="/zsdf/en/firstBlog/">firstBlog</a>
          </li>
        
          <li>
            <a href="/zsdf/en/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zsdf<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/zsdf/" class="mobile-nav-link">Home</a>
  
    <a href="/zsdf/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/zsdf/fancybox/jquery.fancybox.css">
  <script src="/zsdf/fancybox/jquery.fancybox.pack.js"></script>


<script src="/zsdf/js/script.js"></script>



  </div>
</body>
</html>