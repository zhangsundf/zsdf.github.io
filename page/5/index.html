<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>zsdfBlog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="zsdf&apos;s blog">
<meta property="og:type" content="website">
<meta property="og:title" content="zsdfBlog">
<meta property="og:url" content="http://yoursite.com/zsdf/page/5/index.html">
<meta property="og:site_name" content="zsdfBlog">
<meta property="og:description" content="zsdf&apos;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="zsdfBlog">
<meta name="twitter:description" content="zsdf&apos;s blog">
  
    <link rel="alternate" href="/zsdf/atom.xml" title="zsdfBlog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/zsdf/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/zsdf/" id="logo">zsdfBlog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/zsdf/" id="subtitle">zsdf</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/zsdf/">Home</a>
        
          <a class="main-nav-link" href="/zsdf/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/zsdf/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com/zsdf"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-JavaScript中typeof和instanceof用法笔记" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/JavaScript中typeof和instanceof用法笔记/" class="article-date">
  <time datetime="2017-04-12T12:38:26.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/JavaScript中typeof和instanceof用法笔记/">JavaScript中typeof和instanceof用法笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>typeof一般用来获取一个变量或者表达式的类型。</p>
<pre><code>     &gt; typeof undefined
    &apos;undefined&apos;
    &gt; typeof null // well-known bug
    &apos;object&apos;
    &gt; typeof true
    &apos;boolean&apos;
    &gt; typeof 123
    &apos;number&apos;
    &gt; typeof &quot;abc&quot;
    &apos;string&apos;
    &gt; typeof function() {}
    &apos;function&apos;
    &gt; typeof {}
    &apos;object&apos;
    &gt; typeof []
    &apos;object&apos;
    &gt; typeof unknownVariable
    &apos;undefined&apos;

function SuperType(){
         }
console.log(typeof(SuperType));  //function
</code></pre><p>可以看到typeof一般返回值有undefined、Object（包括数组,NULL, 对象）、String、number、Boolean、function.</p>
<p>我们可以使用typeof来获取一个变量是否存在，如<br>if(typeof a!=”undefined”){}，<br>而不要去使用if(a)因为如果a不存在（未声明）则会出错，</p>
<p>正因为typeof遇到null,数组,对象时都会返回object类型，所以当我们要判断一个对象是否是数组时</p>
<p>或者判断某个变量是否是某个对象的实例则要选择使用另一个关键语法instanceof.</p>
<p>instanceofxao操作符是一个双目运算符。判断一个对象是否是另一个对象的实例。<br>function SuperType(){</p>
<p>}<br>var instance = new Supertype();</p>
<p>alert(instance instanceof SuperType); //true;</p>
<p>alert(instance instanceof Object); //true ； 所有引用类型默认都是Object的实例</p>
<p>alert(instance instanceof Function); //false;<br>//instance是一个对象，而不是函数</p>
<p>alert(SuperType instanceof Function); //true ；</p>
<p>var a=new Array();alert(a instanceof Array); //true;</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/JavaScript中typeof和instanceof用法笔记/" data-id="cjl60q3jh000375tf3evhdnx3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-确定实例与原型之间的关系" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/确定实例与原型之间的关系/" class="article-date">
  <time datetime="2017-04-12T12:03:00.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/确定实例与原型之间的关系/">确定实例与原型之间的关系</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>可以使用两种方式确定实例与原型之间的关系：<br>1. instanceof操作符<br>2. isPrototypeOf()方法</p>
<p>先来一段代码：</p>
<pre><code>function SuperType(){ 
this.property = true; 
}

//在SuperType函数的原型链上创建实例共享方法 
SuperType.prototype.getSuperValue = function(){ 
return this.property; 
};

function SubType(){ 
this.subProperty = false; 
}

//继承了SuperType 
SubType.prototype = new SuperType();

SubType.prototype.getSubValue = function(){ 
return this.subProperty; 
}

var instance = new SubType(); 
alert(instance.getSuperValue()); //true;
</code></pre><p><strong>1. instanceof操作符</strong><br>用这个操作符来测试实例与原型链中出现过的构造函数，如果有，就会返回true。或者说判断一个对象是不是另一个对象的实例。</p>
<p>a instanceof b; 如果a是b的实例就返回true<br>基于如上代码：</p>
<pre><code>//instance 是Object的实例吗？


  alert(instance instanceof Object);    //true;
</code></pre><p>//instance 是SuperType的实例吗?</p>
<pre><code>alert(instance instanceof SuperType);    //true;

alert(instance instanceof SubType);    //true;
</code></pre><p><strong>2. isPrototypeOf()方法</strong><br>只要是原型链上出现过的原型，都可以说是该原型链所派生的实例的原型，因此 isPrototypeOf()也会返回true。</p>
<pre><code>//Object的原型在派生instance实例的原型链上？是的话就是instance实例的原型，返回true
alert(Object.prototype. isPrototypeOf(instance));  //true

//SuperType的原型在派生instance实例的原型链上吗？是的话就是instance实例的原型，返回true
alert(SuperType.prototype. isPrototypeOf(instance));  //true

//SubType的原型在派生instance实例的原型链上吗？是的话就是instance实例的原型，返回true
alert(SubType.prototype. isPrototypeOf(instance));  //true
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/确定实例与原型之间的关系/" data-id="cjl60q3kq001e75tfcjwtllwx" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-谈谈对原型链的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/谈谈对原型链的理解/" class="article-date">
  <time datetime="2017-04-12T11:31:16.000Z" itemprop="datePublished">2017-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/谈谈对原型链的理解/">谈谈对原型链的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>许多OO语言支持两种继承方式：接口继承和实现继承。<br>接口继承只继承函数签名，实现继承则继承实际的方法。<br>由于函数无签名，在JavaScript中无法实现接口继承。所以只能实现方法继承。</p>
<p>实现继承主要依赖原型链。<br>什么是原型对象。我们知道每个构造函数一旦创建都有prototype指针指向它的原型对象（构造函数.prototype）。而原型对象（构造函数.prototype）会默认生成一个constructor指针又指向构造函数。在创建实例时，实例有一个内部属性[[prototype]]指向该原型对象。原型对象内创建的所有方法会被所有实例共享。<br>来看段代码：</p>
<pre><code>   function Person{
    };

Person.prototype.name = &quot;Nichloas&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Enginner&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
}
var person1 = new Person();
person1.sayName();    //Nichloas

var person2 = new Person();
person2.sayName();    //Nichloas
</code></pre><p><img src="https://img-blog.csdn.net/20170412183953439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这样看着图，再结合上面的原型对象的解释就明白了。<br><strong>还要说一点就是原型对象中的方法属性是被所有实例共享的。如果含有引用类型的属性，如数组，修改person1中的数组属性，也会导致person2中的该属性发生变化。</strong></p>
<p>看一下什么是原型链。</p>
<p>原型链就是创建一个构造函数，它会默认生成一个prototype属性并指向原型对象。使用下一个构造函数的原型对象作为这个构造函数的实例。即 nextFuction.prototype = new thisFuction();<br>在下下一个构造函数的原型对象 = new nextFuction。这样下去就会构成一条实例与原型之间的链条，这就是原型链。</p>
<p>function SuperType(){<br>this.property = true;<br>}</p>
<p>//在SuperType函数的原型链上创建公共方法<br>SuperType.prototype.getSuperValue = function(){<br>return this.property;<br>};</p>
<p>function SubType(){<br>this.subProperty = false;<br>}</p>
<p>//继承了SuperType<br>SubType.prototype = new SuperType();</p>
<p>SubType.prototype.getSubValue = function(){<br>return this.subProperty;<br>}</p>
<p>var instance = new SubType();<br>alert(instance.getSuperValue()); //true;</p>
<p>函数之间的关系会是什么样子？<br>首先SuperType构造函数创建后会是这样子的：<br><img src="https://img-blog.csdn.net/20170412190000421?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>SuperType函数本身内部会有一个prototype指针，指向SuperType Prototype（图中还没有画出来）而在构造函数创建之后，会按照某种规则生成一个原型对象即SuperType.prototype,该原型对象中默认也会有一个指针constructor再指向构造函数。由于在原型链上我们添加了一个getSuperValue函数，所以会存在原型对象中。</p>
<p>SuperType构造函数中还有一个属性property属性，后面解释。</p>
<p>然后创建了构造函数，再为其创建了属性subProperty。又使其 原型对象成为SuperType构造函数的实例。我们知道实例中会自动生成一个[[prototype]]的内部属性。所以就相当于<strong>该实例的默认方法重写了SubType.prototype（原型对象）。</strong><br>然后再定义添加属性和方法到SubType.prototype中，最后SubType构造函数生成实例instance。<br>看最后的图：<br><img src="https://img-blog.csdn.net/20170412191449810?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>现在来解释一下为什么property属性没有出现在SuperType的原型链中，而出现在了SubType的原型链中。subProperty没有出现在SubType的原型链中，而出现在了instance实例中。<br><strong>因为我们知道在构造函数中定义的属性和方法实际上是实例的属性和方法。即只能出现在实例中。而SubType.prototype是SuperType的实例，所以property属性在其中。</strong>同理因为在构造函数SubType中定义的subProperty属性是实例属性，所以存在于instance中。实例中会有一个[[prototype]]内部属性指向构造函数的原型对象。这样就形成了一条链。<br>在通过原型链实现继承的情况下，当读取模式访问实例中的属性时，会先搜索实例，然后再搜索实例的原型，在一层一层知道找到或者到达原型链的末端停止。<br>其实我们上面的是少一环的，即Object。因为所有引用类型都是从object继承来的。<br><img src="https://img-blog.csdn.net/20170412192722020?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>SubType继承了SuperType，SuperType继承了Object，当调用instance.toString方法，实际是调用了保存在Object中的方法。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/谈谈对原型链的理解/" data-id="cjl60q3kt001j75tfql7fzos4" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-浅谈对-this-指向的理解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/浅谈对-this-指向的理解/" class="article-date">
  <time datetime="2017-04-10T13:40:44.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/浅谈对-this-指向的理解/">浅谈对 this 指向的理解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>在《javaScript语言精粹》这本书中，把 this 出现的场景分为四类，简单的说就是：</p>
<p>有对象就指向调用对象；没调用对象就指向全局对象；用new构造就指向新对象；通过 apply 或 call 或 bind 来改变 this 的所指。</p>
<p><strong>首先理解这句话：this对象是在运行时基于函数的执行环境绑定。</strong></p>
<p>this引用是一种在JavaScript代码中随时都可以使用的只读变量，this引用的是一个对象。因此根据函数的调用方式不同，引用的对象也会有所不同。<br>this会根据代码的上下文语境自动改变其引用。<br>接下来看第一种情况：<br><strong>1. 有对象就指向调用对象</strong></p>
<pre><code>var  name = &quot;this is gloabal&quot;;
var obj = {
    name : &quot;my object&quot;，

   getName : function(){
       return this.name;
   }
}
alert(obj.getName());      //my object
</code></pre><p>函数的执行环境在obj内，所以访问的是obj.name;</p>
<p><strong>2.没对象调用就指向全局对象</strong></p>
<pre><code>var name = &quot; this is global&quot;;
function getName(){
    return this.name;
}
alert(gertName()); //this is global
</code></pre><p><strong>3. 用new构造函数就指向新对象</strong></p>
<pre><code>function getObj(){
 console.log(this);    //控制台输出: getObj{}  
                       //this指向的新创建的getObj对象
    }
new getObj();
}
</code></pre><p><strong>4. 通过 apply 或 call 或 bind 来改变 this 的所指。</strong></p>
<pre><code>var name = &apos;this is window&apos;;  //定义window的name属性,看this.name是否会调用到
var testObj1 = {
    name : &apos;this is testObj1&apos;,
    getName:function(){
        console.log(this);   
        console.log(this.name); 
    }
}

var testObj2 = {
    name: &apos;this is testObj2&apos;
}

//就相当于使testObj1.getName在testObj2的环境中运行。所以得到的是 this is testObj2
testObj1.getName.apply(testObj2);  

  //控制台输出: this is testObj2  
testObj1.getName.call(testObj2);
</code></pre><p><strong>最后有一种情况：</strong></p>
<pre><code>var obj={
    name:&apos;this is obj&apos;,
    getname:function(){
        return function(){
            return this.name;
        }
    }
}
alert(obj.getname()());
</code></pre><p>obj.getname()执行返回的是一个 函数，两个括号就是要执行返回的函数。因为该函数是在windows作用域中执行的，<br>所以 这个this对象 指向的是windows作用域 而非 obj的作用域。</p>
<pre><code>var name = &quot;this is global&quot;;
    var myObject = {
    name : &quot;my object&quot;,
    getValue: function(){

        var foo = function(){
            alert(this.name);
            }
        foo();
    }
}

myObject.getValue();   //this is global
</code></pre><p>在上述代码块中，foo 函数虽然定义在 getValue 的函数体内，但实际上它既不属于 getValue 也不属于 myObject。foo 并没有被绑定在任何对象上，所以当调用时，它的 this 指针指向了全局对象 global。</p>
<p>varname=’this is windows’;<br>varobj={<br>name:’this is obj’,<br>getname:(function(){<br>alert(this.name)<br>})();<br>}<br>同样 该代码 弹出 this is windows;</p>
<p>因为 getname函数会在页面加载的时候就执行，<br>而执行环境是在windows下执行的，所以this 指向的就是windows作用域。<br>千万不要理解为 写在obj体里就认为this对象肯定指向obj体。。这是错误的。。<br><strong>this对象是在运行时基于函数的执行环境绑定。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/浅谈对-this-指向的理解/" data-id="cjl60q3kn001a75tfty1k9a1o" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript创建对象-工厂模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/JavaScript创建对象-工厂模式/" class="article-date">
  <time datetime="2017-04-10T06:17:46.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/JavaScript创建对象-工厂模式/">JavaScript创建对象---工厂模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>在介绍寄生构造函数模式时，先来介绍一下工厂模式<br><strong>1.工厂模式</strong><br>工厂模式是软件工程领域中一种广为认知的设计模式，这种模式抽象了具体创建对象的过程，因为在ECMAScript中无法创建类。开发人员就发明了一种函数，用函数来封装以特定接口创建对象的细节。</p>
<pre><code>function createPerson(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName= function(){
          return (this.name)
     };
     return o;
     }
var person1 = createPerson(&apos;ZhangSan&apos;, 29, &apos;Software Enginner &apos;);
var person2 = createPerson(&apos;LiSi&apos;, 27, &apos;Doctor &apos;);
</code></pre><p>使用工厂模式，可以无数次的调用这个函数。而每次它都会返回一个具有三个属性和一个方法的对象。工厂模式虽然解决了创建多个对象的问题，但却没有解决对象识别的问题（怎样知道一个对象的类型）<br>即<br>console.log(person1 instanceof Object); //true<br>console.log(person2 instanceof Object); //true<br>console.log(person1.constructor == Object); //true<br>console.log(person2.constructor == Object); //true<br>知道person1 和person2 都属于对象，却没办法知道对象的类型。所以就出现了构造函数。</p>
<p>而构造函数上节已经讲过，现在我们要看的就是和工厂模式的定义对象的方法非常相似的寄生构造函数模式。</p>
<p><strong>2. 寄生构造函数模式</strong></p>
<p>在我们前几次讲的几种模式都不适用的情况下，可以使用这种。<br>这种模式的基本思想是创建一个函数，该函数的作用仅仅是封装创建对象的代码。然后再返回新创建的函数。</p>
<pre><code>function Person(name, age, job){
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName= function(){
          return (this.name)
     };
     return o;
     }
var person1 = new  Person(&apos;ZhangSan&apos;, 29, &apos;Software Enginner &apos;);
var person2 = new  Person(&apos;LiSi&apos;, 27, &apos;Doctor &apos;);
</code></pre><p>从表面上看这像是很典型的构造函数。但是除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式其实跟工厂模式是一模一样的。构造函数在不返回值的情况下，默认返回新对象实例。而在构造函数的尾部添加一个return 语句，意味着可以重写调用构造函数时的返回值。</p>
<p>这个模式可以在特殊情况下，用来为对象创建构造函数。</p>
<pre><code>function createPerson(name, age, job){
        var o = new Object();
        o.name = name;
        o.age = age;
        o.job = job;
        o.sayName= function(){
              return (this.name)
         };
         return o;
     }

    function specialPerson(){
     var persons = new createPerson(&apos;LiSi&apos;, 27, &apos;Doctor&apos;);
            persons.alertMsg = function(){
            alert(&apos;new message!&apos;);
        }
        return persons;
        }

    var person1 = new specialPerson();

    person1.alertMsg(); //new message
    alert(person1.sayName());  //LiSi
</code></pre><p>在上面的例子中，我们首先创建了构造函数createPerson(),然后再使用寄生构造函数模式为该函数的内部对象又添加了新的方法。<br>使用var person1 = new specialPerson();创建一个新实例。相当于利用使用构造函数specialPerson创建的实例，也可以访问createPerson中的属性和方法。</p>
<p><strong>注意：返回的对象与构造函数或者构造函数的原型属性之间没有任何关系。也就是说，通过构造函数返回的对象与在构造函数外部创建的对象没有什么不同。因此不能依赖instanceof操作符来确定对象类型。所以一般不建议使用这种模式。</strong></p>
<p><strong>3 .稳妥构造函数模式</strong></p>
<p>所谓稳妥对象，就是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中(这些环境中会禁止使用this和new)。或者在防止数据被其他应用程序改动时使用。</p>
<p>稳妥构造函数模式遵循与寄生构造函数类似的模式。但有区别：<br>①.新创建对象的实例方法不使用this；<br>②.不使用new操作符调用构造函数</p>
<p>则根据稳妥函数的要求，可以将前面的Person改写为：</p>
<pre><code>function Person(name , age, job){
    //创建要返回的对象
    var o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function(){
        alert(name);
    }
//返回对象
return o;
}
 var friend = Person(&quot;Nicholas&quot;, 29, &quot;SoftWare Enginner&quot;);
 friend.sayName();        //Nicholas
</code></pre><p>这样变量friend中保存的是一个稳妥对象，除了调用sayName之外，没有其他方法访问其数据成员。即使有其他代码会为这个对象添加新的方法或者数据成员，但也不会有别的方法访问到传入到构造函数中的原始数据。稳妥函数提供的这种安全性，使得它非常适合在某些安全执行环境下使用。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/JavaScript创建对象-工厂模式/" data-id="cjl60q3jj000575tfwla8jbrs" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-组合使用构造函数模式和原型模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/组合使用构造函数模式和原型模式/" class="article-date">
  <time datetime="2017-04-10T05:47:55.000Z" itemprop="datePublished">2017-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/组合使用构造函数模式和原型模式/">组合使用构造函数模式和原型模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>创建自定义类型最常见的就是组合使用构造函数模式和原型模式。构造函数模式用于定义实例的属性。而原型模式我们上节了解到，主要是用于定义公用的属性和方法。<br>首先看一下构造函数模式创建js对象.</p>
<p><strong>1. 构造函数模式</strong><br>构造函数模式可以用来创建特定类型的对象</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName= function(){
         alert(this.name)
    };
}

var person1 = new Person(&quot;zhangsan&quot;, 29, &quot;Software Enginner&quot;);
var person1 = new Person(&quot;lisi&quot;, 31, &quot;Doctor&quot;);
</code></pre><p>即要创建Person新实例，必须使用new操作符。person1和person2分别保存着Person的一个不同的实例，这两个对象都有constructor属性，且都指向Person。</p>
<p>alert(person1.constructor == Person); //true;<br>alert(person2.constructor == Person); //true;</p>
<p>两个实例相当于都有了构造函数的一个副本，在一个实例中修改属性或者方法，不会影响到另一个实例中的属性和方法。<br>如：</p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName= function(){
         return (this.name)
    };
}

var person1 = new Person(&quot;zhangsan&quot;, 29, &quot;Software Enginner&quot;);
var person2 = new Person(&quot;lisi&quot;, 31, &quot;Doctor&quot;);

person1.name = &quot;wangwu&quot;;
alert(person1.sayName());//wangwu

alert(person2.sayName());//lisi
}
</code></pre><p>所以说构造函数主要用来定义实例特有的属性和方法。而原型模式上节讲过用来定义共享的属性和方法。如果将两者结合起来，就会使实例具有自己特有的属性和方法，又有共享的属性和方法。于是就出现了，</p>
<p><strong>2. 组合使用构造函数和原型模式</strong></p>
<pre><code>function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.friends = [&apos;aa&apos;, &apos;bb&apos;];
}
Person.prototype = {
    constructor:Person,
    SayName : function(){
        alert(this.name);
    }
}

    var person1 = new Person(&quot;zhangsan&quot;, 29, &quot;Software Enginner&quot;);
var person2 = new Person(&quot;lisi&quot;, 31, &quot;Doctor&quot;);


person1.friends.push(&apos;cc&apos;);
alert(person1.friends);    //aa, bb, cc
alert(person2.friends);    // aa, bb
alert(person1.friends === person2.friends);    //false
alert(person1.sayName === person2.sayName);  //true
</code></pre><p>实例中的属性都是在构造函数中定义的。由实例所共享的属性constructor和方法则是在原型对象中定义的。修改了person1中的friends方法并不会影响person2中的方法。这也是构造函数的特性。</p>
<p>这种构造函数与原型模式混成的模式，目前在ECMAScript中使用最广泛，认同度最高的一种创建自定义类型的方法，可以说<strong>这是用来定义引用类型的一种默认模式。</strong></p>
<p><strong>3. 动态原型模式</strong><br>在上面介绍了构造函数模式与组合使用构造函数模式和原型模式之后，又引入了动态原型模式。</p>
<p>动态原型模式将所有信息都封装在了构造函数中，而通过在构造函数中初始化原型(如果有必要的话)，又保持了同时使用构造函数与原型的优点。</p>
<pre><code>function Person(name, age, job){
this.name = name;
this.age = age;
this.job = job;

if(typeof this.sayName != &quot;function&quot;){
    Person.prototype.sayName = function(){
        alert (this.name);
    }
}
</code></pre><p>这样只有在sayName方法不存在的情况下，才会将它添加到原型中。这里对原型所做的修改，会立即在实例中反映出来。</p>
<p><strong>注意：使用动态原型模式时，不能使用对象字面量来重写原型。这样会切断所有实例与新原型之间的联系。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/组合使用构造函数模式和原型模式/" data-id="cjl60q3ks001h75tfda750xz7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-JavaScript创建对象-——-原型模式" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/JavaScript创建对象-——-原型模式/" class="article-date">
  <time datetime="2017-04-09T13:01:24.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/JavaScript创建对象-——-原型模式/">JavaScript创建对象 —— 原型模式</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>我们创建的每个函数都有一个prototype(原型)属性，这个属性是一个指针，指向一个对象，这个对象我们叫它原型对象。而这个原型对象的用途是包含可以由特定类型的所有实例共享的属性和方法。它所包含的属性和方法可以被所有对象实例共享。所以说，在定义构造函数时，不必在其中定义属性和方法，而是在原型对象中定义。如下：</p>
<pre><code>   function Person{
};
Person.prototype.name = &quot;zhangsan&quot;;
Person.prototype.age = 29;
Person.prototype.job = &quot;Software Enginner&quot;;
Person.prototype.sayName = function(){
    alert(this.name);
}

var person1 = new Person();
person1.sayName();    //zhangsan

var person2 = new Person();
person2.sayName();    //zhangsan
</code></pre><p>person1和person2访问的是同一组属性和同一个方法。</p>
<p><strong>1. 原型对象</strong><br>再说了这么多，接下来了解一下原型对象到底是什么,看图说话：<br><img src="https://img-blog.csdn.net/20170409200946587?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>以上面的例子来说：</p>
<p>创建了Person构造函数。原型对象会默认取得constructor属性。Person.prototype指向Person.prototype.constructor<br>Person.prototype.constructor指向Person</p>
<p>再看看开头的几句话。结合图再熟悉一下。我们在例子中定义的属性和方法都添加到了原型对象中。实例化的对象Person1和Person2都可以访问，哪怕还有一个Person10，都可以。</p>
<p>我们注意到，实例化的两个对象都不含有属性和方法，却可以调用Person1.sayName().这是通过查找对象属性的过程来实现的。</p>
<p>来看看是怎样进行查找的：<br><strong>图中我们发现没有什么可以指向Person中的[[Prototype]],但是有isPrototypeOf()方法来确定对象之间是否存在这种关系：</strong><br>alert(Person.prototype.isPrototypeOf(person1)); //true</p>
<p>所以我们知道实例化的对象内部都有一个指向Person.prototype的指针。</p>
<p>还有一个Object.getPrototypeOf()方法。 [[prototype]]的值</p>
<p>alert(Object.getPrototypeOf(person1) == Person.prototype);</p>
<p>//true</p>
<p>因person1中的[[prototype]]与 Person.prototype指的是同一对象。</p>
<p>那么如果实例对象想定义自己的属性和方法怎么办？会不会担心与原型对象中的命名冲突？</p>
<p>其实在实例中创建与原型对象中相同名字的属性和方法，该属性将会覆盖掉原型对象中的同名属性。</p>
<p>还是刚开始的那段代码，在实例时这样：</p>
<pre><code>var person1 = new Person();
person1.name = &quot;lisi&quot;;
person1.name();    //lisi

var person2 = new Person();
person2.sayName();    //zhangsan
</code></pre><p>在定义了实例对象自己的属性或者方法后，如果不想用了，可以利用delete person1.name删除它。删除之后它和原型对象之间的联系又接上了，相当于什么事都没有发生过。还可以照常访问。</p>
<p>既然现在知道了实例中也可以定义属性和方法，怎样判断属性在实例中还是在原型对象中？hasOwnProperty()方法可以进行判断。</p>
<pre><code>var person1 = new Person();

//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //false

person1.name = &quot;lisi&quot;;       //person1定义一个名为name的属性
//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //true

var person2 = new Person();
alert(person2.hasOwnProperty(&quot;name&quot;));   //false
</code></pre><p>看图说话<br><img src="https://img-blog.csdn.net/20170409204227944?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p><strong>2. 原型与in操作符</strong></p>
<pre><code>var person1 = new Person();

//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //false
alert(&quot;name&quot; in person1);   //true;

person1.name = &quot;lisi&quot;;       //person1定义一个名为name的属性
//person1实例中有名为name的属性吗？false
alert(person1.hasOwnProperty(&quot;name&quot;));   //true
alert(&quot;name&quot; in person1);   //true;
</code></pre><p>由上可以得出结论，无论属性在实例中还是在原型中，不能用in来进行判断。但是同时使用hasOwnProperty（）和in就可以准确的进行判断。</p>
<p>for-in循环，返回的是所有可通过对象访问的，可枚举的属性。</p>
<p>要取得对象上所有可枚举的属性，使用Object.keys(对象)；</p>
<p>还是以第一个例子为例：</p>
<pre><code>var keys = Object.keys(Person.prototype);
alert(keys)    //name, age, job, sayName

var p = new Person();
p.name = &quot;lisi&quot;;
p.age = 31;
var keys = Object.keys(p);
alert(keys)    //name, age,
</code></pre><p>如果想要得到所有的实例，无论是否可枚举，使用 Object.getOwnPropertyNames()方法</p>
<p>var keys = Object.getOwnPropertyNames(Person.prototype);<br>alert(keys) //constructor, name, age, job, sayName</p>
<p><strong>3. 使用对象字面量来重写原型对象：</strong><br>function Person{<br>};<br>Person.prototype = {<br><strong>constructor:Person,</strong><br>name ： “zhangsan”,<br>age ： 29,<br>job ： “Software Enginner”,<br>sayName ： function(){<br>alert(this.name);<br>}<br>};</p>
<p>注意黑色加粗部分，因为每创建一个函数，就会同时创建它的prototype对象，因此，这个对象也会自动获得constructor属性，而我们在这里使用的语法完全是重写了默认的prototype对象，因此constructor属性也就变成了新对象的constructor属性。</p>
<p>注意以这种方式设置的constructor属性会导致它的[[Enumerable]]特性是可枚举的，但默认情况下，原生的constructor属性不可枚举。所以使用Object.defineProperty()修改默认属性</p>
<p>//重设构造函数，只适用于ECMAScript5兼容的浏览器<br>Object.defineProperty(person.prototype, “constructor”, {<br>enumerable:false;<br>value:Person<br>});</p>
<p><strong>4. 原型的动态性</strong><br>原型的动态性是什么意思。就是你对原型对象所做的修改会立即在实例中反映出来。即使这个对象在修改原型对象属性之前创建。</p>
<pre><code>var person1 = new Person();

Person.prototype.sayHi = function(){
    alert(&apos;Hi&apos;);
}
person1.sayHi();     //Hi 
</code></pre><p>这是因为我们在找sayHi函数时，首先会在实例中寻找，没有的话再向原型对象中寻找。因为原型对象与实例之间的链接只不过是一个指针，在找到之后，会返回最新的sayHi属性，并返回保存在那里的函数。</p>
<p>尽管可以随时为原型添加属性和方法，并且能够立即在对象实例中反映出来，但如果重写整个原型对象，结果就不一样了</p>
<p>function Person{<br>};</p>
<p>var friend = new Person();</p>
<p>Person.prototype = {<br>constructor:Person,<br>name ： “zhangsan”,<br>age ： 29,<br>job ： “Software Enginner”,<br>sayName ： function(){<br>alert(this.name);<br>}<br>};<br>friend.sayName(); //error</p>
<p><img src="https://img-blog.csdn.net/20170409230739517?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>这是因为，我们知道每创建一个函数，就会自动生成一个原型对象。<br>上面当定义了一个Person构造函数时，其实就已经默认的生成了一个原型对象。只不过没有属性和方法。后来实例了一个对象，此对象指向的是当前没有属性和方法的只有constructor属性的一个原型对象。<br>后来又创建了一个Person的包含属性和方法的原型对象。但是friend却不是指向这个。<br>简言之就是该Person构造函数包含了自身的原型对象和创建的原型对象。</p>
<p><strong>5. 原生对象的原型</strong><br>原型模式的重要性不仅体现在创建自定义类型的方面，就连所有原生的引用类型，就是采用这种模式创建的。<br>如Array.sort()可以在Array.prototype.sort()中也可以访问得到。</p>
<p>所以我们还可以为原型对象的属性和方法进行修改。如添加一个自己定义的函数</p>
<pre><code>Array.prototype.aaa = function(){
    alert(&apos;hello world&apos;);
}

var strings = new Array();
strings.aaa();   //hello world
</code></pre><p><strong>6. 原型对象的问题：</strong><br>对于包含引用类型值得属性来说，原型对象的问题比较突出</p>
<pre><code>   function Person{
};


Person.prototype = {
    constructor:Person,
    name ： &quot;zhangsan&quot;,
    age ： 29,
    job ： &quot;Software Enginner&quot;,
    friends:[&quot;aa&quot;, &quot;bb&quot;],
   sayName ： function(){
    alert(this.name);
}
};
var friend1 = new Person();
var friend 2= new Person();

friend1.friends.push(&apos;cc&apos;);
alert(friend1.friends);    //aa, bb, cc
alert(friend2.friends);    //aa, bb, cc
</code></pre><p>因为friends属性存在于Person.prototype而非friend1中，所以修改原型对象中的属性，也会反映在其他实例中。但是实例一般都要有属于自己的属性和方法，<strong>所以说这也是很少单独使用原型模式的原因了</strong>。</p>
<p>所以就会出现<strong>组合使用构造函数模式和原型模式创建JavaScript对象。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/JavaScript创建对象-——-原型模式/" data-id="cjl60q3l5001m75tf20hf8lly" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-理解立即调用函数-function" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/理解立即调用函数-function/" class="article-date">
  <time datetime="2017-04-08T09:11:58.000Z" itemprop="datePublished">2017-04-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/理解立即调用函数-function/">理解立即调用函数(function(){ ...})();</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>首先来看一个示例：</p>
<pre><code>var img = document.getElementsByTagName(&apos;img&apos;);
        for(var i = 0; i&lt; img.length; i++){

            img[i].onmouseover = function(){
            img[i].style.width = 185 +&apos;px&apos;;
            img[i].style.height = 215 +&apos;px&apos;;
        }

            img[i].onmouseout = function(){
            img[i].style.width = 165 +&apos;px&apos;;
            img[i].style.height = 200 +&apos;px&apos;;
        }
    }
</code></pre><p>以上函数处理的事件是，当鼠标悬浮到某个图片上，该图片相应的变大一点，当鼠标移出后，恢复原来的大小。首先我们能够想到的就是获取所有的图片标签，然后再进行一个循环，为每一个图片绑定一个悬浮移出的事件。看起来是没有任何问题的，但是当真正执行起来确实漏洞百出。<br>for循环只是将所有的图片遍历一遍，并没有真正的为图片绑定事件。<br>而我们要做的就是为所有的图片进行事件绑定。<br>可以使用立即调用的函数表达式。<br>使用</p>
<pre><code>    var img = document.getElementsByTagName(&apos;img&apos;);

    for(var i = 0; i&lt; img.length; i++){

        (function(value){

        img[value].onmouseover = function(){

        img[value].style.width = 185 +&apos;px&apos;;
        img[value].style.height = 215 +&apos;px&apos;;
    }

        img[value].onmouseout = function(){

        img[value].style.width = 165 +&apos;px&apos;;
        img[value].style.height = 200 +&apos;px&apos;;
    }
    })(i);
}
</code></pre><p>将for循环内的代码用立即调用函数包裹起来，就相当于for每次执行就会调用一次该函数，然后将i传递给value,这样可以为每一个图片都可以绑定上相应的事件了。</p>
<p>在理解了一些函数基本概念后，回头看看( function(){…} )()和( function (){…} () )这两种立即执行函数的写法，最初我以为是一个括号包裹匿名函数，并后面加个括号立即调用函数，当时不知道为什么要加括号，后来明白，<strong>要在函数体后面加括号就能立即调用，则这个函数必须是函数表达式，不能是函数声明。</strong></p>
<p>所以说上面的函数还可以这样写成函数表达式的形式：</p>
<pre><code>var a = function(value){

//code

}(i);
//也就相当于是
var a = function(value){

//code

}
//立即调用

a(i);
//在每一次的for循环中，执行一次事件绑定
</code></pre><p>这就是立即调用函数，即遍历每一个i时，将i传进去绑定到图片上。如果不这样为每一个图片绑定事件，利用for循环就只是相当于走了一个过程，而且这个过程是一次走完的，没有实际的动作。</p>
<p>立即调用函数的作用：<br>javascript中没用私有作用域的概念，如果在多人开发的项目上，你在全局或局部作用域中声明了一些变量，可能会被其他人不小心用同名的变量给覆盖掉，根据javascript函数作用域链的特性，可以使用这种技术可以模仿一个私有作用域，用匿名函数作为一个“容器”，“容器”内部可以访问外部的变量，而外部环境不能访问“容器”内部的变量，所以( function(){…} )()内部定义的变量不会和外部的变量发生冲突，俗称“匿名包裹器”或“命名空间”。</p>
<p>下面来一打实例：</p>
<p>复制代码：</p>
<pre><code>1. function(a){
        console.log(a);   //报错,Uncaught SyntaxError: Unexpected token (
}(12);


2. (function(a){
    console.log(a);   //firebug输出123,使用（）运算符
})(123);

3. (function(a){
    console.log(a);   //firebug输出1234，使用（）运算符
}(1234));

4. !function(a){
    console.log(a);   //firebug输出12345,使用！运算符
}(12345);

5. +function(a){
    console.log(a);   //firebug输出123456,使用+运算符
}(123456);

6. -function(a){
    console.log(a);   //firebug输出1234567,使用-运算符
}(1234567);

7. var fn=function(a){
    console.log(a);   //firebug输出12345678，使用=运算符
}(12345678)           
//需要注意的是:这么写只是一个赋值语句,即把函数匿名函数function(a){...}()的返回值赋值给了fn,如果函数没有返回值,那么fn为undefined,


//下面给出2个例子,用来解答读者的疑惑:

8. var fn=function(a){
    console.log(a);   //firebug输出12345678，使用=运算符
}(12345678);
console.info(fn);//控制台显示为undefined;
fn(123);//函数未定义报错,fn is undefiend 

9. var fn=function(a){
    console.log(a);   //firebug输出12345678，使用=运算符
    return 111;
}(12345678);
console.info(fn);//会发现fn就是一个返回值111,而不是一个函数
fn(123);     //报错,因为fn不是一个函数
</code></pre><p>可以看到输出结果，在function前面加！、+、 -甚至是逗号等到都可以起到函数定义后立即执行的效果，而（）、！、+、-、=等运算符，都将函数声明转换成函数表达式，消除了javascript引擎识别函数表达式和函数声明的歧义，告诉javascript引擎这是一个函数表达式，不是函数声明，可以在后面加括号，并立即执行函数的代码。</p>
<p>加括号是最安全的做法，因为！、+、-等运算符还会和函数的返回值进行运算，有时造成不必要的麻烦。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/理解立即调用函数-function/" data-id="cjl60q3kr001g75tf6ucojleo" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-案例十一-、使用jQuery动态追加页面数据以及事件委托" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/案例十一-、使用jQuery动态追加页面数据以及事件委托/" class="article-date">
  <time datetime="2017-04-06T14:45:25.000Z" itemprop="datePublished">2017-04-06</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/案例十一-、使用jQuery动态追加页面数据以及事件委托/">案例十一 、使用jQuery动态追加页面数据以及事件委托</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>我们要执行的任务是页面起初有一部分图片，我们在底下有一个More Photos的链接，点击后，向当前页面后加载一部分图片，再点击该链接，继续加载，直到将我们列出的页面加载完成，此时该链接也消失了。</p>
<p>首先效果图如下：<br><img src="https://img-blog.csdn.net/20170406211625118?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"><br>这个只截取了最底下的一部分页面。在鼠标悬停在图片上时，还会有文字出现，鼠标移出时文字消失。<br>我们现在要做的就是点击底下的MorePhotos链接时，再加载一部分数据，然后再点击在加载一部分数据，直到数据加载完。<br>首先body中代码如下：</p>
<pre><code>&lt;div id = &quot;container&quot;&gt;
&lt;h1&gt; Photo Gallery&lt;/h1&gt;

&lt;div id = &quot;gallery&quot;&gt;
    &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/1.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye ....&lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/2.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye.... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/3.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye.... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
.
.
.
.
//若干图片

&lt;/div&gt;

 &lt;div class = &quot;link&quot;&gt;&lt;a id = &quot;more-photos&quot; href = &quot;1.html&quot;&gt; More Photos &amp;gt;&amp;gt;&lt;/a&gt;&lt;/div&gt; 
&lt;/div&gt;
</code></pre><p>然后在同一根目录下写几个HTML代码片段，用于加载。</p>
<p>如，我这有一个1.html代码如下</p>
<pre><code>&lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/1.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/2.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/3.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/4.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/5.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/6.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;
</code></pre><p>在这个HTML片段中我引入了6个图片。其他的片段如2.html等等都可以仿照上面的这个来写。在定义好了许多个HTML片段后，利用jQuery进行动态追加数据。</p>
<p>首先引入一个jquery库 <a href="http://libs.baidu.com/jquery/1.9.0/jquery.js" target="_blank" rel="noopener">http://libs.baidu.com/jquery/1.9.0/jquery.js</a></p>
<pre><code>&lt;script&gt;
    $(document).ready(function(){
    //首先定义一个变量来记录当前是多少页
        var pageNum = 1;

        //给链接添加点击事件
        $(&quot;#more-photos&quot;).click(function(event){
            event.preventDefault();
            var $link = $(this);

            //获得当前所点链接的url
            var url = $link.attr(&apos;href&apos;);

            //如果该链接的url存在，进行页面追加
            if(url){
                $.get(url, function(data){
                    $(&quot;#gallery&quot;).append(data);
                });

        pageNum ++;
    //总共有十个片段要追加，名称分别为1.html,2.html ...10.html
        当当前页面的总数小于总数时，进行链接更新。
        if(pageNum &lt; 10){
            $link.attr(&apos;href&apos;, &apos;./&apos;+pageNum+&apos;.html&apos;);
                }

        //当将所有片段追加完成后，移除链接。
            else{
                $link.remove();
            }
            }
        })
    });
</code></pre><p>以上的代码就可以进行动态的向页面追加数据了。</p>
<p>但是在谷歌的浏览器中会出现以下的错误：</p>
<p>jquery.js:8475 XMLHttpRequest cannot load file:///C:/Users/%E9%95%BF%E5%AD%99%E4%B8%B9%E5%87%A4/Desktop/webtest/1.html. Cross origin requests are only supported for protocol schemes: http, data, chrome, chrome-extension, https.</p>
<p>在IE10的环境下进行测试的，没问题。<br>解决办法就是装一个web服务器，然后将文件拷到项目中，以web服务器中的路径访问，就没有问题啦！形如<a href="http://localhost:8080/ajax/ajaxLoad.html" target="_blank" rel="noopener">http://localhost:8080/ajax/ajaxLoad.html</a></p>
<p>由于还有鼠标悬浮事件，当我们将鼠标悬浮在某个图片上时，就会出现文字，移出时，图片上的文字消失。</p>
<pre><code>$(document).ready(function(){
        $(&apos;div .photo&apos;).hover(function(){
            $(this).find(&apos;.details&apos;).fadeTo(&apos;slow&apos;, 0.7);
        },function(){
                $(this).find(&apos;.details&apos;).fadeOut(&apos;slow&apos;);
        })
    });
或者可以将上面的代码组合起来减少冗余代码：

$(document).ready(function(){
    $(&apos;div.photo&apos;).on(&apos;mouseenter mouseleave&apos;, 
            function(event){
            var $details = $(this).find(&apos;.details&apos;);
            if(event.type == &apos;mouseenter&apos;){
                $details.fadeTo(&apos;slow&apos;, 0.7);
                //0.7代表的是透明度
            }
            else{
                $details.fadeOut(&apos;slow&apos;);
            }
        })
});
</code></pre><p><strong>当我们使用上面的两种代码为每个图片添加鼠标悬浮事件时，只有最初页面上的那些图片才会被绑定事件，而经过动态加载的图片上却没能绑定上事件。因为事件处理程序只会添加到调用方法时已经存在的元素上，像通过这种动态追加的元素，不会绑定那些事件。</strong><br><strong>所以有两种解决方案：</strong><br><strong>1. 在动态加载后重新绑定事件处理程序</strong><br><strong>2. 一开始就把事件绑定在存在的元素上，依赖于事件冒泡。</strong></p>
<p>接下来就是使用jquery的委托方法;</p>
<pre><code>$(document).ready(function(){
        $(&apos;#gallery&apos;).on(&apos;mouseenter mouseleave&apos;, &apos;div.photo&apos;, function(event){

            var $details = $(this).find(&apos;.details&apos;);
            if(event.type == &apos;mouseenter&apos;){
                $details.fadeTo(&apos;slow&apos;, 0.7);
            }
            else{
                $details.fadeOut(&apos;slow&apos;);
            }
        })
    })
</code></pre><p><strong>$(‘#gallery’).on(‘mouseenter mouseleave’, ‘div.photo’, function(event)中，在将’div.photo’作为第二个参数的情况下，.on()方法会把 this映射到 gallery中与该选择符匹配的元素。换句话说，就是this指向gallery中的 div class= ‘photo’的元素。</strong></p>
<p>所以在最后追加的页面中，由于都属于gallery 下的元素，所以每一个图片都会加上相应的事件。<br>或许在你不知道要添加的页面属于哪个父级元素的话，可以将$(‘#gallery’).on( )中的’#gallery’替换成document。这样就不必担心选错容器。因为document是页面中所有元素的祖先。<br>但使用document有弊端：<br>当DOM嵌套结构很深，事件冒泡通过大量的祖先元素会有较大的性能损失。<br>但是还会有其他的原因让我们选择document作为委托作用域。<br>一般来说，只有当相应的DOM元素加载完毕，才会给它绑定事件处理程序。这就是为什么我们要把代码放到<code>$(document).ready(function(){}</code>内部的原因。可是document元素是随着页面加载几乎就立即可以调用的。把处理程序绑定到document不用等到完整的DOM构建结束。如上面的代码可以写为：‘</p>
<pre><code>(function($){
        $(document).on(&apos;mouseenter mouseleave&apos;, &apos;div.photo&apos;, function(event){

            var $details = $(this).find(&apos;.details&apos;);
            if(event.type == &apos;mouseenter&apos;){
                $details.fadeTo(&apos;slow&apos;, 0.7);
            }
            else{
                $details.fadeOut(&apos;slow&apos;);
            }
        })
    })(jQuery);
</code></pre><p>因为没有等到整个文档就绪，所以可以确保所有<code>&lt;div class= &#39;photo&#39;&gt;</code>元素只要呈现在页面上，就可以应用mouseenter 和mouseleave行为。</p>
<p>上面就是关于利用jQuery动态追加页面数据以及事件委托的全部知识。下面附上源代码；</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset = &quot;utf-8&quot; /&gt;
    &lt;title&gt;动态加载&lt;/title&gt;
    &lt;script type=&quot;text/javascript&quot; src = &quot;http://libs.baidu.com/jquery/1.9.0/jquery.js&quot;&gt;&lt;/script&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    *{
        margin: 0px;
        padding: 0px;
    }


    #container{
        position: relative;
        width: 1300px;
        margin: 0 auto;
        /*background-color: #ccc;
        height: auto;*/
    }
    #gallery{
        position: relative;
        width: 1300px;
        margin: 0 auto;

    }
    .details{
        display: none;
    }

    .photo{
        padding: 20px;
        border-radius: 5px;
        border:1px solid #ccc;
        box-shadow: 0 0 5px #ccc;
        float: left;
        margin: 8px;
    }

    .photo img{

        /*z-index: 1;*/
        width: 200px;
        height: 300px;
        clear: both;
    }

    .photo .details{
        position: absolute;
        z-index: 2;
        padding-left: 20px;
        margin-top:-200px;
        /*clear: both;*/
        overflow: hidden;
    }
    .description{
        overflow: hidden;
        width: 200px;
        color: lightgreen;
        font-size: 18px;
        font-weight: bold;
    }

    .date{
        font-size:16px;
        margin: 20px 0px;
        color: red; 
    }
    .photographer{
        font-size:14px;
        font-family: &quot;Arial&quot; ;
    }
    .link a{

        clear: both;
        text-decoration: none;
        padding-left: 90%;


    }
    h1{
        text-align: center; 
    }
    &lt;/style&gt;

    &lt;script&gt;
    $(document).ready(function(){

        var pageNum = 1;
        $(&quot;#more-photos&quot;).click(function(event){
            event.preventDefault();
            var $link = $(this);
            var url = $link.attr(&apos;href&apos;);
            console.log(url);
            if(url){
                $.get(url, function(data){
                    $(&quot;#gallery&quot;).append(data);
                });

                pageNum ++;
                if(pageNum &lt; 4){
                    $link.attr(&apos;href&apos;, &apos;./&apos;+pageNum+&apos;.html&apos;);
                }


            else{
                $link.remove();
            }
            }
        })
    })

    // $(document).ready(function(){
    //  $(&apos;div .photo&apos;).hover(function(){
    //      $(this).find(&apos;.details&apos;).fadeTo(&apos;slow&apos;, 0.7);
    //  },function(){
    //          $(this).find(&apos;.details&apos;).fadeOut(&apos;slow&apos;);
    //  })
    // })

    $(document).ready(function(){
        $(&apos;#gallery&apos;).on(&apos;mouseenter mouseleave&apos;, &apos;div.photo&apos;, function(event){

            var $details = $(this).find(&apos;.details&apos;);
            if(event.type == &apos;mouseenter&apos;){
                $details.fadeTo(&apos;slow&apos;, 0.7);
            }
            else{
                $details.fadeOut(&apos;slow&apos;);
            }
        })
    })

    &lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id = &quot;container&quot;&gt;
&lt;h1&gt; Photo Gallery&lt;/h1&gt;

&lt;div id = &quot;gallery&quot;&gt;
    &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/1.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye ....&lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/2.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye.... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/3.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye.... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/4.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye .....&lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/5.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye ....&lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/6.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye ...&lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/7.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye.... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/8.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye..... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/9.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye ...... &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/10.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/11.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/12.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;


        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/13.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/14.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

        &lt;div class = &quot;photo&quot;&gt;
        &lt;img src = &quot;./images/15.jpg&quot;&gt;
        &lt;div class = &quot;details&quot;&gt;
            &lt;div class = &quot;description&quot;&gt;The Cullin Mountains, Isle of skye &lt;/div&gt;
            &lt;div class = &quot;date&quot;&gt;12/24/2000&lt;/div&gt;
            &lt;div class = &quot;photographer&quot;&gt; Alasdair Dougall&lt;/div&gt;
        &lt;/div&gt;
    &lt;/div&gt;

&lt;/div&gt;

 &lt;div class = &quot;link&quot;&gt;&lt;a id = &quot;more-photos&quot; href = &quot;1.html&quot;&gt; More Photos &amp;gt;&amp;gt;&lt;/a&gt;&lt;/div&gt; 
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/案例十一-、使用jQuery动态追加页面数据以及事件委托/" data-id="cjl60q3lj001z75tfo7i06x8h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-案例十-、JavaScript瀑布流布局" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/zsdf/en/案例十-、JavaScript瀑布流布局/" class="article-date">
  <time datetime="2017-04-05T14:47:36.000Z" itemprop="datePublished">2017-04-05</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/zsdf/en/案例十-、JavaScript瀑布流布局/">案例十 、JavaScript瀑布流布局</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <a id="more"></a>
<p>先说一下什么是瀑布流布局。</p>
<p>就是一堆等宽不等高的数据块组成的页面，如图：<br><img src="https://img-blog.csdn.net/20170405202927054?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>现在好多网站都采用这种瀑布流布局，如蘑菇街。美丽说等等。<br>首先要实现它就要明白它是怎样排列的。<br>每一行的列数都是根据图片的宽度和页面的宽度算比例算下来的。。<br>第一行就是按顺序排列，其他的数据块都是在每一列中挑选出最低的那一列依次排进去的。</p>
<p>首先实现框架。</p>
<pre><code>&lt;div id = &quot;main&quot;&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/0.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/1.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/2.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/3.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/4.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/5.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/6.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/7.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/8.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/9.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/10.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/11.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/12.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/13.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/14.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>这里定义了14个图片，每个图片都被一个class= box的属性和class= “pic”的属性包裹，在css中定义其样式：</p>
<pre><code>*{
        padding: 0px;
        margin: 0px;
    }

    #main{
        position: relative;

    }
    .box{
/*      display: inline-block;*/
        padding: 15px 0px 0px 15px;
        float: left;

    }
    .pic{
        padding: 10px;
        border-radius: 5px;
        border:1px solid #ccc;
        box-shadow: 0 0 5px #ccc;
    }

    .pic img{
        width: 165px;
        height: auto;
    }
    &lt;/style&gt;
</code></pre><p>效果图如下：<br><img src="https://img-blog.csdn.net/20170405203920263?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>其实每一行六个图片不是固定的，当你缩小窗口时，它会成为两列，或者三列四列。但我们为了以后的布局，就将它设置为固定的列数，即根据窗口的大小除以图片的大小，向下取整。</p>
<p>接下来写的是js实现的瀑布流布局。<br>在写代码之前，由于要用到box属性，而js中没有直接定义获得class的方法，所以我们在这儿要写一个获得class的方法：</p>
<pre><code>function getByClass(parent,className){

    var boxArr = new Array();//用来获取所有class为box的元素

    oElement = parent.getElementsByTagName(&apos;*&apos;);

    for (var i = 0; i &lt;oElement.length; i++) {

        if(oElement[i].className == className){

            boxArr.push(oElement[i]);

        }
    };
    return boxArr;
}
</code></pre><p>两个参数分别是父元素和要查找的classname。</p>
<p>接下来写函数：</p>
<pre><code>//首先在onload函数中调用函数

window.onload = function(){
    waterFull(&apos;main&apos;,&apos;box&apos;);
}


function waterFull(parent,children){

    //先获得父元素及其底下所有的class = box的元素
    var oParent = document.getElementById(parent);
    var oBoxs =  getByClass(oParent,children);

//我们在前面说过，数据块的列数我们是希望不变的。由于每个数据块都是等宽的，所以可以以第一个数据块的宽度为准，获得数据块的宽度。再计算数据块的列数，向下取整。
    var oBoxW = oBoxs[0].offsetWidth;
    var cols = Math.floor(document.documentElement.clientWidth/oBoxW);

接下来设置父元素的样式，我们需要获得它的宽度，并且使其居中
oParent.style.cssText = &apos;width:&apos; cols * oBoxW + &apos;px; margin: 0 auto&apos;;

//在定义好了所有的样式之后，就是排列数据块。首先第一行是直接排列的。定义一个数组存放每一列的高度，从第二行开始，使得每一个数据块都排在高度最低的那一列。首先得遍历所有的box，即oBoxs

var arrH = []; //定义数组存放每一列的高度
for(var i = 0; i&lt; oBoxs.length; i++){
    //当是第一行时，直接将数据块依次排列，并在数组中记录每一列的高度
    if(i &lt; cols){
        arrH[i] = oBoxs[i].offsetHeight;
    }
    //当i&gt;cols时，即要对前面的所有列的高度进行遍历，将下一个图片放在合适的位置。
    else{
    //首先在数组中找到高度最低的列数。我们都知道有Math.min可以找到最小的数字，但是它接受的参数必须是一组数字，所以在这里我们要用Math.min.apply()方法

    var minH = Math.min.apply(null, arrH);  //定义一个变量，存放数组中最小的高度

    //在找出了最小高度之后，我们需要知道它的索引，才能够为接下来的数据块找到合适的位置，所以在下面又定义了一个找出最小值下标的函数。

    //定义一个变量去接受getMinhIndex函数的返回值
    var minIndex = getMinhIndex(arrH,minH);

    //在获得了高度最小的列数的索引后，就可以将下一个元素放到合适的位置
    oBoxs[i].style.position = &apos;absolute&apos;;
    oBoxs[i].style.top = minH + &apos;px&apos;;
    oBoxs[i].style.left = minIndex * oBoxW + &apos;px&apos;;

    //将当前的数据块终于都放到了合适的位置，但不要忘了更新arrH数组
    arrH[minIndex] += oBoxs[i].offsetHeight; 
    }

}

}


//获取当前最小值得下标
function getMinhIndex(array,min){

    for(var i in array){

        if(array[i] == min)

            return i;
    }
}
</code></pre><p>以上就是完整的瀑布流布局的js实现代码。效果图如下：<br><img src="https://img-blog.csdn.net/20170405211715002?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3Nkbl96c2Rm/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>附上源代码：</p>
<p>js代码：</p>
<pre><code>window.onload = function(){
    waterFull(&apos;main&apos;,&apos;box&apos;);
}

function waterFull(parent,children){
    var oParent = document.getElementById(parent);
    //var oBoxs = parent.querySelectorAll(&quot;.box&quot;);

     var oBoxs = getByClass(oParent,children);

    //计算整个页面显示的列数

    var oBoxW = oBoxs[0].offsetWidth;

    var cols = Math.floor(document.documentElement.clientWidth/oBoxW);

    //设置main的宽度，并且居中

    oParent.style.cssText = &apos;width:&apos;+oBoxW * cols +&apos;px; margin: 0 auto&apos;;

    //找出高度最小的图片，将下一个图片放在下面

    //定义一个数组，存放每一列的高度，初始化存的是第一行的所有列的高度

    var arrH = [];

    for(var i = 0; i&lt; oBoxs.length ; i++){
        if(i &lt; cols){
            arrH.push(oBoxs[i].offsetHeight);
        }
        else{
            var minH = Math.min.apply(null,arrH);

            var minIndex = getMinhIndex(arrH,minH);

            oBoxs[i].style.position = &apos;absolute&apos;;
            oBoxs[i].style.top= minH + &apos;px&apos;;
            oBoxs[i].style.left = minIndex * oBoxW + &apos;px&apos;; 
        //  oBoxs[i].style.left = arrH[minIndex].;

            arrH[minIndex] += oBoxs[i].offsetHeight; 
        }
    }


}
function getByClass(parent,className){

    var boxArr = new Array();//用来获取所有class为box的元素

    oElement = parent.getElementsByTagName(&apos;*&apos;);

    for (var i = 0; i &lt;oElement.length; i++) {

        if(oElement[i].className == className){

            boxArr.push(oElement[i]);

        }
    };
    return boxArr;
}


//获取当前最小值得下标
function getMinhIndex(array,min){

    for(var i in array){

        if(array[i] == min)

            return i;
    }
}
</code></pre><p>html以及css代码：</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset = &quot;utf-8&quot; /&gt;
&lt;script src = &quot;./jswaterfll.js&quot;&gt;&lt;/script&gt;
    &lt;title&gt;瀑布流布局&lt;/title&gt;
    &lt;style type=&quot;text/css&quot;&gt;
    *{
        padding: 0px;
        margin: 0px;
    }

    #main{
        position: relative;

    }
    .box{
/*      display: inline-block;*/
        padding: 15px 0px 0px 15px;
        float: left;

    }
    .pic{
        padding: 10px;
        border-radius: 5px;
        border:1px solid #ccc;
        box-shadow: 0 0 5px #ccc;
    }

    .pic img{
        width: 165px;
        height: auto;
    }
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id = &quot;main&quot;&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/0.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/1.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/2.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/3.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/4.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/5.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/6.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/7.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;

    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/8.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/9.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/10.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/11.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/12.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/13.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/14.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/15.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/16.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/17.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/18.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/19.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/20.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class = &quot;box&quot;&gt;
        &lt;div class = &quot;pic&quot;&gt;
            &lt;img src = &quot;images/21.jpg&quot;&gt;
        &lt;/div&gt;
    &lt;/div&gt;
&lt;/div&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/zsdf/en/案例十-、JavaScript瀑布流布局/" data-id="cjl60q3l9001t75tfmy6dxq6h" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/zsdf/page/4/">&laquo; Prev</a><a class="page-number" href="/zsdf/">1</a><span class="space">&hellip;</span><a class="page-number" href="/zsdf/page/3/">3</a><a class="page-number" href="/zsdf/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/zsdf/page/6/">6</a><a class="page-number" href="/zsdf/page/7/">7</a><a class="page-number" href="/zsdf/page/8/">8</a><a class="extend next" rel="next" href="/zsdf/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/09/">September 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/07/">July 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/06/">June 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/zsdf/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/zsdf/tw/Hello-World/">Hello World</a>
          </li>
        
          <li>
            <a href="/zsdf/en/post-Asset-Folder/">post_Asset_Folder</a>
          </li>
        
          <li>
            <a href="/zsdf/en/My-Gallery/">My Gallery</a>
          </li>
        
          <li>
            <a href="/zsdf/en/firstBlog/">firstBlog</a>
          </li>
        
          <li>
            <a href="/zsdf/en/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 zsdf<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/zsdf/" class="mobile-nav-link">Home</a>
  
    <a href="/zsdf/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/zsdf/fancybox/jquery.fancybox.css">
  <script src="/zsdf/fancybox/jquery.fancybox.pack.js"></script>


<script src="/zsdf/js/script.js"></script>



  </div>
</body>
</html>